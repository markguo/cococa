url:  http://blog.csdn.net/im3094/article/details/1627676
title: linux下几种加锁方法的比较
postdate: 2007-05-28 00:10

<em> real&#160;&#160;&#160; 0m3.280s user&#160;&#160;&#160; 0m1.943s sys&#160;&#160;&#160;&#160; 0m1.216s  &#20449;&#21495;&#37327;&#38145; real&#160;&#160;&#160; 0m31.255s user&#160;&#160;&#160; 0m8.996s sys&#160;&#160;&#160;&#160; 0m21.111s  pthread_mutex_t  real&#160;&#160;&#160; 0m0.018s user&#160;&#160;&#160; 0m0.015s sys&#160;&#160;&#160;&#160; 0m0.003s </em>  &#19982;stevens&#22312;APUE&#37324;&#35760;&#36848;&#30340;&#32467;&#26524;&#24688;&#22909;&#30456;&#21453;&#12290; &#28304;&#20195;&#30721;&#22914;&#19979;&#65306; <span class="Title"><span style="font-weight: bold;"></span>&#13;
<textarea readonly="readonly" name="code" class="csharp">#include &lt;pthread.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;&#13;
&#13;
void test_filelock(int locktimes)&#13;
{&#13;
#include &lt;sys/types.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;fcntl.h&gt;&#13;
&#13;
        struct flock lock, unlock;&#13;
        int count = 0;&#13;
        int fd;&#13;
&#13;
        lock.l_type = F_WRLCK;&#13;
        lock.l_start = 0;&#13;
        lock.l_whence = SEEK_SET;&#13;
        lock.l_len = 1;&#13;
&#13;
        unlock.l_type = F_ULOCK;&#13;
        unlock.l_start = 0;&#13;
        unlock.l_whence = SEEK_SET;&#13;
        unlock.l_len = 1;&#13;
&#13;
        fd = open("lock.test", O_CREAT);&#13;
&#13;
        for (count = 0; count &lt; locktimes; ++count){&#13;
                fcntl(fd, F_SETLKW, &amp;lock);&#13;
                fcntl(fd, F_SETLKW, &amp;unlock);&#13;
        }&#13;
}&#13;
&#13;
void test_pthread_lock(int locktimes)&#13;
{&#13;
        int i;&#13;
        for (i = 0; i &lt; locktimes; ++i){&#13;
                pthread_mutex_lock(&amp;mutex);&#13;
                pthread_mutex_unlock(&amp;mutex);&#13;
        }&#13;
}&#13;
&#13;
void test_semlock(int locktimes)&#13;
{&#13;
#include &lt;sys/types.h&gt;&#13;
#include &lt;sys/ipc.h&gt;&#13;
#include &lt;sys/sem.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
        struct sembuf bufLock, bufUnlock;&#13;
        int iCount = 0;&#13;
&#13;
        int semid = semget(0x33332222, 1, IPC_CREAT|0666);&#13;
&#13;
        if (semid == -1){&#13;
                printf("semget error/n");&#13;
                return ;&#13;
        }&#13;
&#13;
        semctl(semid, 0, SETVAL, 1);&#13;
&#13;
        bufLock.sem_num = 0;&#13;
        bufLock.sem_op = -1;&#13;
        bufLock.sem_flg = SEM_UNDO;&#13;
&#13;
        bufUnlock.sem_num = 0;&#13;
        bufUnlock.sem_op = 1;&#13;
        bufUnlock.sem_flg = SEM_UNDO;&#13;
&#13;
        for ( iCount = 0; iCount &lt; 10000000; ++iCount){&#13;
                semop(semid, &amp;bufLock, 1);&#13;
                semop(semid, &amp;bufUnlock, 1);&#13;
        }&#13;
}&#13;
&#13;
int main(int argc, char **argv)&#13;
{&#13;
        if(argc != 3){&#13;
                printf("usage: test_lock file|sem|pthread locktimes/n");&#13;
                exit(1);&#13;
        }&#13;
&#13;
        int locktimes = atoi(argv[2]);&#13;
        if(strcmp(argv[1], "file") == 0)&#13;
                test_filelock(locktimes);&#13;
        else if(strcmp(argv[1], "sem") == 0)&#13;
                test_semlock(locktimes);&#13;
        else&#13;
                test_pthread_lock(locktimes);&#13;
&#13;
        return 0;&#13;
}&#13;
&#13;
</textarea>&#13;
&#21478;&#22806;&#65292;&#22914;&#26524;&#21482;&#38656;&#35201;&#19968;&#25226;&#38145;&#30340;&#35805;&#65292;flock&#20351;&#29992;&#26356;&#26041;&#20415;&#65292;&#25928;&#29575;&#19978;&#20110;&#35760;&#24405;&#38145;&#22522;&#26412;&#30456;&#21516; &#160;</span>&#13;

